/*
 * generated by Xtext 2.28.0
 */
package org.uppaal.scoping;

import static com.google.common.collect.Iterables.concat;
import static com.google.common.collect.Iterables.filter;
import static com.google.common.collect.Iterables.size;
import static org.eclipse.xtext.scoping.Scopes.scopeFor;

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.uppaal.NTA;
import org.uppaal.core.IdentifiableElement;
import org.uppaal.core.NamedElement;
import org.uppaal.core.TypedElement;
import org.uppaal.declarations.DeclarationsPackage;
import org.uppaal.declarations.Function;
import org.uppaal.declarations.SystemDeclarations;
import org.uppaal.declarations.TypeDeclaration;
import org.uppaal.declarations.TypedDeclaration;
import org.uppaal.declarations.TypedElementContainer;
import org.uppaal.declarations.Variable;
import org.uppaal.expressions.ChannelPrefixExpression;
import org.uppaal.expressions.DataPrefixExpression;
import org.uppaal.expressions.Expression;
import org.uppaal.expressions.ExpressionsPackage;
import org.uppaal.expressions.FunctionCallExpression;
import org.uppaal.expressions.IdentifierExpression;
import org.uppaal.expressions.QuantificationExpression;
import org.uppaal.expressions.ScopedIdentifierExpression;
import org.uppaal.statements.Block;
import org.uppaal.statements.Iteration;
import org.uppaal.templates.Edge;
import org.uppaal.templates.Template;
import org.uppaal.templates.TemplatesPackage;
import org.uppaal.types.DeclaredType;
import org.uppaal.types.StdLib;
import org.uppaal.types.StructTypeSpecification;

/**
 * This class contains custom scoping description.
 * See <a href="https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping">
 *     https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping</a>
 * on how and when to use it.
 */
public class UppaalXMLScopeProvider extends AbstractUppaalXMLScopeProvider {
	private enum ScopeMode {
		TYPES, TYPED_ELEMENTS, TYPES_AND_TYPED_ELEMENTS
	}
	
	private static com.google.common.base.Function<IdentifiableElement, QualifiedName> getIdentifyableName =
			(element) -> QualifiedName.create(element.getId());
			
	/**
	 * Helper method that appends the TypedElements of a TypedElementContainer to a given
	 * Iterable for NamedElements.
	 */
	private static Function2<Iterable<NamedElement>, TypedElementContainer, Iterable<NamedElement>> TypedElementContainerReduction =
			(a, b) -> concat(a, filter(b.getElements(), NamedElement.class));
	/**
	 * Helper method that appends the Types of a TypeDeclaration to a given
	 * Iterable for NamedElements.
	 */
	private static Function2<Iterable<NamedElement>, TypeDeclaration, Iterable<NamedElement>> TypeDeclarationReduction =
			(a, b) -> concat(a, filter(b.getType(), NamedElement.class));

	private static <T,V,B extends T> T reduce(Iterable<V> iterable, B base, Function2<? super T, ? super V, ? extends T> function) {
		T value = base;
		
		Iterator<V> iterator = iterable.iterator();
		while(iterator.hasNext()) {
			value = function.apply(value, iterator.next());
		}
		
		return value;
	}
	
	private static <T,V> Iterable<T> reduce(Iterable<V> iterable, Function2<? super Iterable<T>, ? super V, ? extends Iterable<T>> function) {
		return reduce(iterable, List.<T>of(), function);
	}
			
    @Override
    public IScope getScope(EObject context, EReference reference) {
    	if (reference == TemplatesPackage.Literals.TEMPLATE__INIT) {
    		Template template = (Template) context;
    		return Scopes.scopeFor(template.getLocation(), getIdentifyableName, IScope.NULLSCOPE);
    	}
    	
    	if (reference == TemplatesPackage.Literals.EDGE__SOURCE) {
    		Template template = (Template) context.eContainer();
        	return Scopes.scopeFor(template.getLocation(), getIdentifyableName, IScope.NULLSCOPE);
    	}
    	
    	if (reference == TemplatesPackage.Literals.EDGE__TARGET) {
    		Template template = (Template) context.eContainer();
        	return Scopes.scopeFor(template.getLocation(), getIdentifyableName, IScope.NULLSCOPE);
    	}
    	
    	if (reference == ExpressionsPackage.Literals.IDENTIFIER_EXPRESSION__IDENTIFIER) {
    		final IdentifierExpression expression = (IdentifierExpression) context;
        	return getIdentifierScope(expression);
    	}
    	
    	if (reference == ExpressionsPackage.Literals.CHANNEL_PREFIX_EXPRESSION__CHANNEL_TYPE) {
			final ChannelPrefixExpression expression = (ChannelPrefixExpression) context;
			return getChannelPrefixScope(expression);
		}
    	
        return super.getScope(context,reference);
    }
    
    /**
	 * Main method to find the scope corresponding to a given IdentifierExpression.
	 * It checks for certain special cases an then delegates to more specialized
	 * methods.
	 * 
	 * @param identifierExpression The IdentifierExpression that needs resolving.
	 * 
	 * @return Scope for the IdentifierExpression.
	 */
	private IScope getIdentifierScope(IdentifierExpression identifierExpression) {
		// Filter out cases where we may only reference instances of Type.
		
		final UppaalScopingSwitch<IScope> scopingSwitch = new UppaalScopingSwitch<>() {
			@Override
			public IScope handleCase(TypeDeclaration declaration) {
				if (identifierExpression.eContainingFeature() == DeclarationsPackage.Literals.TYPE_DECLARATION__TYPE_DEFINITION) {
					return scopeTypes();
				}
				
				return defaultCase(declaration);
			}
			
			@Override
			public IScope handleCase(TypedElementContainer container) {
				if (identifierExpression.eContainingFeature() == DeclarationsPackage.Literals.TYPED_ELEMENT_CONTAINER__TYPE_DEFINITION) {
					return scopeTypes();
				}
				
				return defaultCase(container);
			}
			
			@Override 
			public IScope handleCase(DataPrefixExpression expression) {
				return scopeTypes();
			}
			
			private IScope scopeTypes() {
				return getRecursiveTypesScope(identifierExpression);
			}
			
			@Override
			public IScope defaultCase(EObject object) {
				return getRecursiveScope(identifierExpression, ScopeMode.TYPED_ELEMENTS);
			}
			
		};
		
		return scopingSwitch.doSwitch(identifierExpression.eContainer());
	}
	
	/**
	 * Method to find the scope corresponding to a given ChannelPrefixExpression.
	 * Such an expression is restricted to the built-in 'chan' type, however that
	 * type could have been be redefined using a 'typedef' declaration. To support
	 * redefined channel types as well, this method returns a recursive scope of
	 * arbitrary types.
	 *
	 * @param channelPrefixExpression The ChannelPrefixExpression that needs
	 *                                resolving.
	 *
	 * @return Scope for the ChannelPrefixExpression.
	 */
	private IScope getChannelPrefixScope(ChannelPrefixExpression channelPrefixExpression) {
		return getRecursiveTypesScope(channelPrefixExpression);
	}
		
	/**
	 * Checks whether the given ScopedIdentifierExpression follows the structure that
	 * we can scope, i.e. if the "scope" is either an IdentifierExpression or a valid
	 * ScopedIdentifierExpression and the identifier is an IdentifierExpression.
	 * 
	 * FunctionCallExpressions can be scoped as well, iff. a Template is called.
	 * 
	 * @param expr The ScopedIdentifierExpression to check.
	 * 
	 * @return A boolean indicating whether the structure is valid or not.
	 */
	private boolean checkScopedIdentifierExpressionStructure(ScopedIdentifierExpression expr) {
		final UppaalScopingSwitch<Boolean> scopingSwitch = new UppaalScopingSwitch<>() {
			@Override
			public Boolean handleCase(IdentifierExpression expression) {
				return true;
			}
			
			@Override
			public Boolean handleCase(ScopedIdentifierExpression scopedExpression) {
				return true;
			}
			
			@Override
			public Boolean handleCase(FunctionCallExpression functionExpression) {
				return TemplatesPackage.Literals.TEMPLATE.isInstance(functionExpression.getFunction());
			}
			
			@Override
			public Boolean defaultCase(EObject object) {
				return false;
			}
		};
		
		return scopingSwitch.doSwitch(expr.getScope());
	}

	/**
	 * Specifically scopes ScopedIdentifierExpressions. The method assumes that the
	 * structure of the expression is valid, i.e. checkScopedIdentifierExpression
	 * returned true.
	 * 
	 * @param expr The ScopedIdentifierExpression whose identifier attribute should
	 * be resolved.
	 * 
	 * @return A scope that hopefully includes the referenced element.
	 */
	private IScope getScopedIdentifierExpressionScope(ScopedIdentifierExpression expr) {
		// Define variables.
		StructTypeSpecification struct = null;
		IScope scope = IScope.NULLSCOPE;
		IdentifierExpression identifier = null;

		// Check on which level of the ScopedIdentifierExpression we currently are
		// and get the relevant scope identifier.
		final Expression expressionScope = expr.getScope();
		
		if (expressionScope instanceof IdentifierExpression) {
			identifier = (IdentifierExpression) expressionScope;
		}
		
		if (expressionScope instanceof ScopedIdentifierExpression) {
			identifier = ((ScopedIdentifierExpression) expressionScope).getIdentifier();
		}
		
		if (expressionScope instanceof FunctionCallExpression) {
			final FunctionCallExpression functioncall = (FunctionCallExpression) expressionScope;
			return getFunctionCallScopeForTemplate((Template) functioncall.getFunction());
		}
		
		// Try to find a struct through the given identifier, i.e. the identifier
		// should point to a variable of a struct type.
		final NamedElement identifierElement= identifier.getIdentifier();
		
		if (identifierElement instanceof TypedElement) {
			Expression typeDefinition = ((TypedElement) identifierElement).getTypeDefinition();
			
			// Check if we have some typedefs we need to trace first.
			while ((typeDefinition instanceof IdentifierExpression)
					&& ((IdentifierExpression) typeDefinition).getIdentifier() instanceof DeclaredType){
				typeDefinition = ((DeclaredType) ((IdentifierExpression) typeDefinition).getIdentifier()).getTypeDefinition(); 
			}
			
			// If we found a struct, remember it.
			if (typeDefinition instanceof StructTypeSpecification)
				struct = (StructTypeSpecification) typeDefinition;
		}

		// If we found a struct, then we can add its elements to the scope.
		if (struct != null) {
			// Add all elements of the struct to the current scope.
			Iterable<TypedDeclaration> elements = struct.getDeclaration();
					
			// Create the new scope.
			scope = scopeFor(reduce(elements, TypedElementContainerReduction), IScope.NULLSCOPE);
		}
		
		return scope;
	}



    private IScope getFunctionCallScopeForTemplate(Template template) {
    	return scopeFor(template.getLocation(), getRecursiveScope(template, ScopeMode.TYPED_ELEMENTS));
	}

	/**
	 * Recursive strategy to find the scope of arbitrary EObjects. Essentially, the
	 * containment tree is traversed and on relevant objects the scope is extended.
	 * It is recursive as we go up in the containment tree, thus encountering inner
	 * scopes first and outer scopes last. This is easier to do with recursion.
	 * 
	 * @param object EObject for which to calculate the scope.
	 * @param mode Mode telling us whether to scope for TypedElements or Types.
	 * 
	 * @return An appropriate scope representation for the EObject.
	 */
	private IScope getRecursiveScope(EObject object, ScopeMode mode) {
		// Define local variables.
		Iterable<NamedElement> elements = new LinkedList<>();
		EObject curObj = object.eContainer();
		EObject lastObj = object;
		ScopeMode curMode = mode;
		
		final UppaalScopingSwitch<Iterable<NamedElement>> typedElementSwitch = new UppaalScopingSwitch<>() {
			@Override
			public Iterable<NamedElement> handleCase(NTA nta) {
				Iterable<TypedDeclaration> declarations = filter(
						nta.getGlobalDeclarations().getDeclaration(),
						TypedDeclaration.class);
				
				return reduce(declarations, TypedElementContainerReduction);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(Template template) {
				Iterable<NamedElement> parameterNames = reduce(template.getParameter(), TypedElementContainerReduction);
				Iterable<NamedElement> declarationNames = reduce(filter(template.getDeclarations().getDeclaration(),TypedDeclaration.class), TypedElementContainerReduction);
				
				return concat(parameterNames, declarationNames);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(Function function) {
				return reduce(function.getParameter(), TypedElementContainerReduction);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(Block block) {
				return reduce(filter(block.getDeclarations().getDeclaration(), TypedDeclaration.class), TypedElementContainerReduction);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(Iteration iteration) {
				return filter(iteration.getElements(), NamedElement.class);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(SystemDeclarations systemDeclarations) {
				return reduce(filter(systemDeclarations.getDeclaration(), TypedDeclaration.class), TypedElementContainerReduction);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(Edge edge) {
				return reduce(edge.getSelection(), TypedElementContainerReduction);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(QuantificationExpression expression) {
				return filter(expression.getElements(), NamedElement.class);
			}
			
			@Override
			public Iterable<NamedElement> defaultCase(EObject obj) {
				return Collections.emptyList();
			}
		};
		
		final UppaalScopingSwitch<Iterable<NamedElement>> typedDeclarationSwitch = new UppaalScopingSwitch<>() {
			@Override
			public Iterable<NamedElement> handleCase(NTA nta) {
				Iterable<TypeDeclaration> typeDeclarations = filter(nta.getGlobalDeclarations().getDeclaration(), TypeDeclaration.class);
				return concat(reduce(typeDeclarations, TypeDeclarationReduction), StdLib.ALL_TYPES);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(Template template) {
				return reduce(filter(template.getDeclarations().getDeclaration(), TypeDeclaration.class), TypeDeclarationReduction);
			}
			
			@Override
			public Iterable<NamedElement> handleCase(SystemDeclarations systemDeclarations) {
				return reduce(filter(systemDeclarations.getDeclaration(), TypeDeclaration.class), TypeDeclarationReduction);
			}
			
			@Override
			public Iterable<NamedElement> defaultCase(EObject obj) {
				return Collections.emptyList();
			}
		};
				
		// Check objects and go up in the containment tree.
		while(curObj != null) {
			
			if(curObj instanceof Variable) {
				// In Variable indices, Type references are also allowed.
				if("index".equals(lastObj.eContainmentFeature().getName()))
					curMode = ScopeMode.TYPES_AND_TYPED_ELEMENTS;
			}
			
			if(curObj instanceof ScopedIdentifierExpression) {
				final ScopedIdentifierExpression expression = (ScopedIdentifierExpression) curObj;
				// The ScopedIdentifierExpression needs custom scoping, because it
				// may restrict the scope to certain structs etc.
				// For purposes of simplicity, we only scope simple chains of the form
				//    variable.struct_var1.struct_var2...
				// Complex scopes like
				//    (cond?variable1:variable2).struct_var1
				// will not be parsed.
				// TODO: Scope complex scopes.
				if ("identifier".equals(lastObj.eContainmentFeature().getName())
						&& checkScopedIdentifierExpressionStructure(expression)) {
					return getScopedIdentifierExpressionScope(expression);
				}
			}
				
			// Scope for TypedElement's.
			if(curMode == ScopeMode.TYPED_ELEMENTS || curMode == ScopeMode.TYPES_AND_TYPED_ELEMENTS) {
				elements = concat(elements, typedElementSwitch.doSwitch(curObj));
			}
					
			// Scope for DeclaredType and Type.
			if(curMode == ScopeMode.TYPES_AND_TYPED_ELEMENTS || curMode == ScopeMode.TYPES) {
				elements = concat(elements, typedDeclarationSwitch.doSwitch(curObj));
			}
			
			// Create a new scope if necessary.
			if(size(elements) > 0) {
				return scopeFor(elements, getRecursiveScope(curObj, mode));
			}
			
			lastObj = curObj;
			curObj = curObj.eContainer();
		}
		
		// In case of failure or end of recursion, return the empty scope.
		return IScope.NULLSCOPE;
	}
	
	private IScope getRecursiveTypesScope(EObject object) {
		return getRecursiveScope(object, ScopeMode.TYPES);
	}

}
